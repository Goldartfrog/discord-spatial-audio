<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpatialVoice</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a1a;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 24px;
        }

        .status {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #f04747;
        }

        .status-dot.connected {
            background: #43b581;
        }

        .setup {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #444;
            background: #2f2f2f;
            color: #fff;
            font-size: 14px;
            width: 200px;
        }

        button {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            background: #5865f2;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }

        button:hover {
            background: #4752c4;
        }

        canvas {
            border-radius: 8px;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .instructions {
            margin-top: 20px;
            color: #888;
            font-size: 14px;
            text-align: center;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <h1>SpatialVoice</h1>
    
    <div class="status">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">Disconnected</span>
        <span id="channelInfo"></span>
    </div>

    <div class="setup">
        <input type="text" id="username" placeholder="Discord username (e.g. goldartfrog)">
        <button id="connectBtn">Connect</button>
    </div>

    <p class="hint" style="color: #666; font-size: 12px; margin-bottom: 20px;">
        Make sure you've joined a Discord voice channel with the plugin enabled first!
    </p>

    <canvas id="canvas" width="600" height="600"></canvas>

    <div class="instructions">
        <p>Enter your Discord username, then drag your circle to move.</p>
        <p>Others will hear you based on distance!</p>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-dot" style="background: #5865f2;"></div>
                <span>You</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #43b581;"></div>
                <span>Close (loud)</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #f04747;"></div>
                <span>Far (quiet)</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const connectBtn = document.getElementById('connectBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const usernameInput = document.getElementById('username');

        const CANVAS_SIZE = 600;
        const USER_RADIUS = 25;
        const MAX_DISTANCE = 300;

        // Server URL - change this to your server
        const SERVER_URL = 'ws://216.15.14.234:34197';

        let ws = null;
        let positions = {};
        let myVisibleId = null;
        let myPos = { x: CANVAS_SIZE / 2, y: CANVAS_SIZE / 2 };
        let isDragging = false;

        // Connect to WebSocket server
        function connect() {
            const username = usernameInput.value.trim();

            if (!username) {
                alert('Please enter your Discord username');
                return;
            }

            myVisibleId = username;

            if (ws) {
                ws.close();
            }

            ws = new WebSocket(SERVER_URL);

            ws.onopen = () => {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
                connectBtn.textContent = 'Disconnect';
                
                // Send initial position
                sendPosition();
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'positions') {
                    positions = data.positions;
                    draw();
                }
            };

            ws.onclose = () => {
                statusDot.classList.remove('connected');
                statusText.textContent = 'Disconnected';
                connectBtn.textContent = 'Connect';
                ws = null;
            };

            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
            };
        }

        function disconnect() {
            if (ws) {
                ws.close();
            }
        }

        connectBtn.addEventListener('click', () => {
            if (ws) {
                disconnect();
            } else {
                connect();
            }
        });

        // Send position update to server
        function sendPosition() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'updatePosition',
                    visibleId: myVisibleId,
                    x: myPos.x,
                    y: myPos.y
                }));
            }
        }

        // Calculate distance between two points
        function getDistance(p1, p2) {
            return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
        }

        // Draw everything
        function draw() {
            // Clear
            ctx.fillStyle = '#2f3136';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Draw grid
            ctx.strokeStyle = '#40444b';
            ctx.lineWidth = 1;
            for (let i = 0; i <= CANVAS_SIZE; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, CANVAS_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(CANVAS_SIZE, i);
                ctx.stroke();
            }

            // Draw distance circles around me
            ctx.strokeStyle = '#4f545c';
            ctx.setLineDash([5, 5]);
            for (let r = 100; r <= MAX_DISTANCE; r += 100) {
                ctx.beginPath();
                ctx.arc(myPos.x, myPos.y, r, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Draw other users
            for (const [visibleId, pos] of Object.entries(positions)) {
                if (visibleId === myVisibleId) {
                    // Update my position from server (in case it changed)
                    myPos = { x: pos.x, y: pos.y };
                    continue;
                }

                const distance = getDistance(myPos, pos);
                const ratio = Math.min(distance / MAX_DISTANCE, 1);
                
                // Green (close) to red (far)
                const r = Math.round(255 * ratio);
                const g = Math.round(255 * (1 - ratio));
                const color = `rgb(${r}, ${g}, 100)`;

                // Circle
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, USER_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Name
                ctx.fillStyle = '#fff';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(visibleId, pos.x, pos.y + USER_RADIUS + 18);

                // Volume percentage
                const volume = Math.round(100 - (ratio * 100));
                ctx.fillStyle = '#aaa';
                ctx.font = '12px sans-serif';
                ctx.fillText(`${volume}%`, pos.x, pos.y + USER_RADIUS + 34);
            }

            // Draw me (on top)
            ctx.beginPath();
            ctx.arc(myPos.x, myPos.y, USER_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = '#5865f2';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // My name
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(myVisibleId || 'You', myPos.x, myPos.y + USER_RADIUS + 18);
        }

        // Mouse handling
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking on myself
            if (getDistance({ x, y }, myPos) <= USER_RADIUS) {
                isDragging = true;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;

            // Clamp to canvas
            x = Math.max(USER_RADIUS, Math.min(CANVAS_SIZE - USER_RADIUS, x));
            y = Math.max(USER_RADIUS, Math.min(CANVAS_SIZE - USER_RADIUS, y));

            myPos = { x, y };
            sendPosition();
            draw();
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        // Touch handling for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            if (getDistance({ x, y }, myPos) <= USER_RADIUS) {
                isDragging = true;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            let x = touch.clientX - rect.left;
            let y = touch.clientY - rect.top;

            x = Math.max(USER_RADIUS, Math.min(CANVAS_SIZE - USER_RADIUS, x));
            y = Math.max(USER_RADIUS, Math.min(CANVAS_SIZE - USER_RADIUS, y));

            myPos = { x, y };
            sendPosition();
            draw();
        });

        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });

        // Initial draw
        draw();
    </script>
</body>
</html>
